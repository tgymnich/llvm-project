; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=arm64-none-linux-gnu -mattr=+neon -O2 | FileCheck %s

; st2 must before two ldrb.
; The situation that put one ldrb before st2 because of the conservative memVT set for st2lane,
; which lead to basic-aa goes wrong.

define dso_local i32 @test_vst2_lane_u8([2 x <8 x i8>] %vectors.coerce) local_unnamed_addr {
; CHECK-LABEL: test_vst2_lane_u8:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    // kill: def $d1 killed $d1 killed $q0_q1 def $q0_q1
; CHECK-NEXT:    add x8, sp, #12
; CHECK-NEXT:    // kill: def $d0 killed $d0 killed $q0_q1 def $q0_q1
; CHECK-NEXT:    umov w9, v1.b[6]
; CHECK-NEXT:    st2 { v0.b, v1.b }[6], [x8]
; CHECK-NEXT:    umov w8, v0.b[6]
; CHECK-NEXT:    ldrb w10, [sp, #13]
; CHECK-NEXT:    ldrb w11, [sp, #12]
; CHECK-NEXT:    cmp w10, w9, uxtb
; CHECK-NEXT:    ccmp w11, w8, #0, eq
; CHECK-NEXT:    cset w0, ne
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    ret
entry:
  %temp = alloca [2 x i8], align 4
  %vectors.coerce.fca.0.extract = extractvalue [2 x <8 x i8>] %vectors.coerce, 0
  %vectors.coerce.fca.1.extract = extractvalue [2 x <8 x i8>] %vectors.coerce, 1
  call void @llvm.lifetime.start.p0(i64 2, ptr nonnull %temp) #4
  call void @llvm.aarch64.neon.st2lane.v8i8.p0(<8 x i8> %vectors.coerce.fca.0.extract, <8 x i8> %vectors.coerce.fca.1.extract, i64 6, ptr nonnull %temp)
  %0 = load i8, ptr %temp, align 4
  %vget_lane = extractelement <8 x i8> %vectors.coerce.fca.0.extract, i64 6
  %cmp8.not = icmp ne i8 %0, %vget_lane
  %arrayidx3.1 = getelementptr inbounds [2 x i8], ptr %temp, i64 0, i64 1
  %1 = load i8, ptr %arrayidx3.1, align 1
  %vget_lane.1 = extractelement <8 x i8> %vectors.coerce.fca.1.extract, i64 6
  %cmp8.not.1 = icmp ne i8 %1, %vget_lane.1
  %or.cond = select i1 %cmp8.not, i1 true, i1 %cmp8.not.1
  %cmp.lcssa = zext i1 %or.cond to i32
  call void @llvm.lifetime.end.p0(i64 2, ptr nonnull %temp) #4
  ret i32 %cmp.lcssa
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2
declare void @llvm.aarch64.neon.st2lane.v8i8.p0(<8 x i8>, <8 x i8>, i64, ptr nocapture) #2
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2
